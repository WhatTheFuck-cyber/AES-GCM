# 一、MixColumns和inv MixColumns的计算差异

在AES算法中，`MixColumns`（列混合）和`inv MixColumns`（逆列混合）的计算差异大，本质上是由它们的**数学作用和逆操作关系**决定的。


### 核心原因：一个是“加密扩散”，一个是“解密还原”
AES的安全性依赖于“扩散”和“混淆”：  
- `MixColumns`是加密过程中的“扩散”步骤，目的是让一个字节的变化影响到整个列，甚至整个状态矩阵，增强加密的复杂性；  
- `inv MixColumns`是解密过程中的逆操作，必须**精确还原**`MixColumns`的结果，让加密后的列变回原始状态。  

两者是严格的“逆运算”关系，就像“乘法”和“除法”的关系――要还原`a × b`的结果，必须用`(a×b) ÷ b`，而“除法”的计算逻辑显然和“乘法”不同。


### 数学本质：基于有限域上的矩阵逆
`MixColumns`和`inv MixColumns`的计算本质是\(GF(2^8)\)有限域上的矩阵乘法，但使用的矩阵是互逆的。  

- **`MixColumns`的矩阵**：  
  加密时，每个列向量会与一个固定的4×4矩阵相乘（矩阵元素是GF(2?)中的元素）：  
  ```
  [02 03 01 01]
  [01 02 03 01]
  [01 01 02 03]
  [03 01 01 02]
  ```
  这个矩阵的作用是通过有限域乘法和异或（）混合列中字节，实现扩散。

- **`inv MixColumns`的矩阵**：  
  解密时，必须用上述矩阵的**逆矩阵**，才能抵消`MixColumns`的作用（矩阵相乘后得到单位矩阵，相当于“无操作”）。逆矩阵为：  
  ```
  [0E 0B 0D 09]
  [09 0E 0B 0D]
  [0D 09 0E 0B]
  [0B 0D 09 0E]
  ```
  逆矩阵的元素（0x0E、0x0B等）是通过解有限域上的线性方程组得到的，确保与原矩阵相乘后结果为单位矩阵。


### 为什么系数差异大？
原矩阵和逆矩阵的元素（如0x02 vs 0x0E，0x03 vs 0x0B）看起来差异大，是因为：  
1. 有限域GF(2?)的乘法规则特殊（不是普通整数乘法），逆运算的结果并不直观；  
2. 逆矩阵需要满足“与原矩阵相乘=单位矩阵”，这个约束决定了其元素必须是特定值，无法和原矩阵元素保持简单对应（比如“倒数”关系）。  


### 总结
`MixColumns`和`inv MixColumns`的计算差异，是“加密扩散”和“解密还原”的功能需求导致的――前者用特定矩阵增强混淆，后者必须用其逆矩阵精确还原，而有限域的数学特性让这种逆关系看起来差异显著。

# 二、AES 块加密流程
AES（Advanced Encryption Standard）是一种对称分组密码，用于加密固定长度的块（通常为128位，也支持192位和256位）。对单块的加密流程基于多轮迭代，每轮包含特定的变换操作，核心是通过“混淆”和“扩散”增强安全性。以下是128位块（最常用）的详细加密流程（密钥长度128位时为10轮，192位12轮，256位14轮，此处以128位为例）。


### **前提：状态矩阵与轮密钥**
AES将128位输入块视为一个4×4的字节矩阵，称为**状态（State）**，每个元素是8位字节（0-255）。例如，128位输入按顺序拆分为16个字节`b0~b15`，状态矩阵的排列为**列优先**：  
```
[ s0,0  s0,1  s0,2  s0,3 ]  ← 第0行：b0, b4, b8, b12  
[ s1,0  s1,1  s1,2  s1,3 ]  ← 第1行：b1, b5, b9, b13  
[ s2,0  s2,1  s2,2  s2,3 ]  ← 第2行：b2, b6, b10, b14  
[ s3,0  s3,1  s3,2  s3,3 ]  ← 第3行：b3, b7, b11, b15  
```

此外，AES通过**密钥扩展算法**从原始密钥生成多轮所需的“轮密钥”（每轮128位，与块长度相同）。128位密钥需生成11个轮密钥（包括初始轮），记为`w0~w10`。


### **加密总流程**
128位密钥的加密分为**11个阶段**：1个初始轮（仅轮密钥加）+ 9个主轮（4步操作）+ 1个最后轮（3步操作）。**【请注意，不同位数密钥的 AES 加密/解密仅仅只有`密钥派生算法`和`主轮次数`略有不同，其他操作完全一致】**
具体如下：  
`初始轮（AddRoundKey）→ 主轮1~9（SubBytes→ShiftRows→MixColumns→AddRoundKey）→ 最后轮10（SubBytes→ShiftRows→AddRoundKey）`  


### **详细步骤解析**

#### **1. 初始轮：AddRoundKey（轮密钥加）**  
初始轮仅执行一次，作用是将输入状态与第一个轮密钥（`w0`）进行**逐字节异或**。  
- 操作：状态中每个字节`s[i][j]`与轮密钥对应位置的字节`w0[i][j]`异或，结果仍存入`s[i][j]`。  
- 目的：将密钥信息引入初始状态，异或操作可逆（解密时用相同轮密钥再次异或即可恢复）。  


#### **2. 主轮（第1~9轮）：4步操作**  
每轮包含4个步骤，按顺序执行，目的是增强混淆（非线性）和扩散（信息分散）。  


##### **步骤1：SubBytes（字节替换）**  
对状态矩阵中的每个字节进行**非线性替换**，使用固定的8×8置换表（S盒）。  
- S盒的生成：基于GF(2?)（8位二进制域）中的乘法逆运算，再叠加一个仿射变换（线性变换+常量异或），确保输出与输入的非线性关系。  
- 操作：每个字节`s[i][j]`（取值0-255）替换为S盒中对应位置的值，例如`s=0x00`→`0x63`，`s=0x01`→`0x7c`等。  
- 目的：通过非线性变换打破输入与输出的线性相关性。  


##### **步骤2：ShiftRows（行移位）**  
对状态矩阵的行进行**循环左移**，实现行内的信息扩散。  
- 移位规则：  
  - 第0行：不移位（保持原样）；  
  - 第1行：左移1位（例如`[a,b,c,d]`→`[b,c,d,a]`）；  
  - 第2行：左移2位（例如`[a,b,c,d]`→`[c,d,a,b]`）；  
  - 第3行：左移3位（例如`[a,b,c,d]`→`[d,a,b,c]`）。  
- 示例（移位后）：  
  ```
  原状态：          移位后：  
  [s0,0 s0,1 s0,2 s0,3]   [s0,0 s0,1 s0,2 s0,3]  
  [s1,0 s1,1 s1,2 s1,3]   [s1,1 s1,2 s1,3 s1,0]  
  [s2,0 s2,1 s2,2 s2,3]   [s2,2 s2,3 s2,0 s2,1]  
  [s3,0 s3,1 s3,2 s3,3]   [s3,3 s3,0 s3,1 s3,2]  
  ```  
- 目的：将不同列的字节混合到同一行，增强横向扩散。  


##### **步骤3：MixColumns（列混合）**  
将状态矩阵的每一列视为GF(2?)上的4维向量，与一个固定矩阵相乘，实现列内的信息扩散。  
- 固定矩阵（用于列混合的系数）：  
  ```
  [02 03 01 01]  
  [01 02 03 01]  
  [01 01 02 03]  
  [03 01 01 02]  
  ```  
  其中`01,02,03`是GF(2?)中的元素（对应十进制1,2,3）。  

- 操作：对每一列`c`（0≤c≤3），新值`s'[i][c]`由下式计算（运算在GF(2?)中，加法为异或，乘法为模`0x11b`（即多项式x?+x?+x?+x+1）的乘法）：  
  - `s'[0][c] = (02 × s[0][c])  (03 × s[1][c])  (01 × s[2][c])  (01 × s[3][c])`  
  - `s'[1][c] = (01 × s[0][c])  (02 × s[1][c])  (03 × s[2][c])  (01 × s[3][c])`  
  - `s'[2][c] = (01 × s[0][c])  (01 × s[1][c])  (02 × s[2][c])  (03 × s[3][c])`  
  - `s'[3][c] = (03 × s[0][c])  (01 × s[1][c])  (01 × s[2][c])  (02 × s[3][c])`  

- 目的：通过线性变换将列内字节的影响扩散到整个列，增强纵向扩散。  


##### **步骤4：AddRoundKey（轮密钥加）**  
与初始轮类似，将当前状态与本轮的轮密钥（`w1~w9`）逐字节异或。  
- 操作：`s[i][j] = s[i][j]  w轮[i][j]`。  
- 目的：将密钥信息再次融入状态，且异或操作不影响之前的混淆和扩散效果。  


#### **3. 最后轮（第10轮）：3步操作**  
最后一轮与主轮的区别是**移除MixColumns**，仅保留3步：`SubBytes→ShiftRows→AddRoundKey`。  
- 原因：解密时需逆操作，最后一轮若保留MixColumns，会导致解密流程复杂；移除后可确保加密的最终输出直接与密钥关联，且不影响安全性。  


### **总结**  
AES对单块的加密流程通过“初始轮密钥加→多轮SubBytes/ShiftRows/MixColumns/轮密钥加→最后轮SubBytes/ShiftRows/轮密钥加”的迭代，实现了输入块与密钥的深度混合。其中：  
- SubBytes提供非线性混淆；  
- ShiftRows和MixColumns提供信息扩散；  
- AddRoundKey将密钥融入每一轮。  

这些操作的组合使AES具有高安全性和高效性，成为当前应用最广泛的加密标准。

# 三、AES 解密流程
AES解密是加密的逆过程，但并非简单地反向执行加密步骤，而是通过**逆操作**和**反向轮次**实现。解密流程需对应加密的每一步执行逆变换，且轮密钥的使用顺序与加密相反。以下以128位密钥（10轮加密）为例，详细说明解密流程，192位和256位密钥的解密逻辑相同，仅轮数对应加密轮数（12轮和14轮）。


### **核心原则**
- 解密的**轮次顺序与加密相反**（加密：轮0→轮1→…→轮10；解密：轮10→轮9→…→轮0）。  
- 加密中每一步操作都有对应的**逆操作**（部分操作的逆操作与原操作不同）。  
- 轮密钥的使用顺序与加密相反（加密用`w0~w10`，解密用`w10~w0`）。  


### **解密与加密的操作对应关系**
加密的4个核心操作（SubBytes、ShiftRows、MixColumns、AddRoundKey）在解密中需执行对应的逆操作，具体对应关系如下：

| 加密操作         | 解密逆操作         | 说明                                                                 |
|------------------|--------------------|----------------------------------------------------------------------|
| AddRoundKey      | AddRoundKey        | 逆操作与原操作相同（异或自身两次可恢复原值）                         |
| SubBytes         | InvSubBytes        | 使用“逆S盒”（Inverse S-Box）进行字节替换，是SubBytes的逆置换         |
| ShiftRows        | InvShiftRows       | 行循环右移（加密是左移），移位位数与加密对应                         |
| MixColumns       | InvMixColumns      | 使用逆矩阵进行列混合，是MixColumns的逆变换（在GF(2?)中）             |


### **128位密钥AES的解密流程（对应10轮加密）**
加密流程为：`初始轮（w0）→ 主轮1-9（w1-w9）→ 最后轮10（w10）`  
解密流程为：`初始解密轮（w10）→ 解密主轮1-9（w9-w1）→ 最终解密轮（w0）`  


#### **1. 初始解密轮（对应加密的最后轮10）**  
输入：加密后的128位密文块（状态矩阵）。  
操作：仅1步――`AddRoundKey`（使用加密最后一轮的轮密钥`w10`）。  
- 原因：加密最后轮的最后一步是`AddRoundKey（w10）`，解密第一步需先用`w10`异或恢复该步骤前的状态。  


#### **2. 解密主轮1-9（对应加密的主轮9-1）**  
共9轮，每轮包含4步操作，**顺序与加密主轮相反**（加密：SubBytes→ShiftRows→MixColumns→AddRoundKey；解密：InvShiftRows→InvSubBytes→AddRoundKey→InvMixColumns）。  

##### **步骤1：InvShiftRows（逆行移位）**  
- 目的：恢复加密中ShiftRows的移位效果。  
- 规则（与加密ShiftRows反向，行循环右移）：  
  - 第0行：不移位；  
  - 第1行：右移1位（例如`[b,c,d,a]`→`[a,b,c,d]`）；  
  - 第2行：右移2位（例如`[c,d,a,b]`→`[a,b,c,d]`）；  
  - 第3行：右移3位（例如`[d,a,b,c]`→`[a,b,c,d]`）。  


##### **步骤2：InvSubBytes（逆字节替换）**  
- 目的：恢复加密中SubBytes的非线性替换。  
- 操作：使用“逆S盒”（Inverse S-Box）对每个字节进行替换。逆S盒是S盒的逆置换，生成方式为：先对字节做逆仿射变换，再求GF(2?)中的乘法逆（0x00仍映射为0x00）。  


##### **步骤3：InvAddRoundKey（轮密钥加）**  
- 操作：将当前状态与本轮的轮密钥（`w9~w1`，按解密轮次依次使用）逐字节异或。  
- 目的：恢复加密中对应轮的AddRoundKey操作（异或可逆）。  
- 注意：解密轮密钥的生成与加密相同，但使用顺序相反。对于单个轮密钥而言，其InvAddRoundKey操作与加密的AddRoundKey操作相同。


##### **步骤4：InvMixColumns（逆列混合）**  
- 目的：恢复加密中MixColumns的列混合效果。  
- 操作：对每一列使用逆矩阵进行GF(2?)上的矩阵乘法，逆矩阵如下：  
  ```
  [0e 0b 0d 09]  
  [09 0e 0b 0d]  
  [0d 09 0e 0b]  
  [0b 0d 09 0e]  
  ```  
  其中`0e,0b,0d,09`是GF(2?)中的元素，乘法和加法规则与加密的MixColumns一致（加法为异或，乘法模`0x11b`）。  


#### **3. 最终解密轮（对应加密的初始轮）**  
最后一轮解密不包含`InvMixColumns`（对应加密初始轮没有MixColumns），仅3步操作：  
`InvShiftRows → InvSubBytes → AddRoundKey`  

- 步骤1：InvShiftRows（同解密主轮的步骤1）；  
- 步骤2：InvSubBytes（同解密主轮的步骤2）；  
- 步骤3：AddRoundKey（使用加密初始轮的轮密钥`w0`）。  

输出：经过上述操作后，状态矩阵恢复为原始的128位明文块（若明文曾填充，需移除填充字节）。  


### **不同密钥长度的解密轮数对应**
| 密钥长度 | 加密轮数 | 解密轮数 | 解密轮密钥使用顺序       |
|----------|----------|----------|--------------------------|
| 128位    | 10轮     | 10轮     | w10 → w9 → ... → w0      |
| 192位    | 12轮     | 12轮     | w12 → w11 → ... → w0     |
| 256位    | 14轮     | 14轮     | w14 → w13 → ... → w0     |  


### **总结**  
AES解密的核心是通过**逆操作**（InvSubBytes、InvShiftRows、InvMixColumns）和**反向轮次**（从最后一轮到初始轮），配合轮密钥的反向使用，逐步恢复明文。其中：  
- 逆操作确保每一步都能撤销加密的变换；  
- 轮次和轮密钥的反向顺序确保从密文回溯至明文；  
- AddRoundKey因异或的可逆性，其逆操作与原操作相同。  

这种设计既保证了解密的正确性，又维持了AES的安全性和高效性。



# 四、AES 分块问题

AES（Advanced Encryption Standard）的**分块大小是固定的128位**，与密钥长度（128位、192位、256位）无关。这意味着无论使用哪种长度的密钥，AES都会将明文分割为128位（16字节）的块进行加密。不同密钥长度的区别主要体现在**加密轮数**和**密钥扩展算法**上，而非分块方式。


### 1. 分块加密的基础：固定128位块
AES是“分组密码”（Block Cipher），其核心设计是对**固定长度的块**进行加密。所有密钥长度的AES都遵循这一规则：  
- 明文会被分割为**128位（16字节）的块**，每个块独立进行加密处理；  
- 若明文长度不是128位的整数倍，需通过“填充”（如PKCS#7、ISO/IEC 9797-1等标准）补足至128位的整数倍；  
- 加密后，每个128位的明文块会生成一个128位的密文块，最终所有密文块拼接为完整密文。  


### 2. 分块加密的完整流程（适用于所有密钥长度）
无论密钥是128位、192位还是256位，分块加密的整体流程一致，仅在“轮数”和“轮密钥生成”上有差异。具体步骤如下：  


#### 2.1 明文分块与填充
- **分块**：将明文按128位（16字节）分割为若干块。例如，30字节的明文会被分为2个块：第1块16字节，第2块14字节（需填充2字节）。  
- **填充**：对最后一个不足128位的块进行填充，确保长度为128位。以PKCS#7为例，若需填充n字节，则每个填充字节的值均为n（如需填充2字节，则补充`0x02 0x02`）。  


#### 2.2 单个块的加密（核心流程）
每个128位的明文块会被转换为4×4的“状态矩阵”（如前文所述），然后通过多轮迭代加密。不同密钥长度的**轮数不同**：  
- 128位密钥：10轮加密（1轮初始轮 + 9轮主轮 + 1轮最后轮）；  
- 192位密钥：12轮加密（1轮初始轮 + 10轮主轮 + 1轮最后轮）；  
- 256位密钥：14轮加密（1轮初始轮 + 12轮主轮 + 1轮最后轮）。  

每轮的操作与前文128位密钥的流程一致：  
- 初始轮：仅`AddRoundKey`（与初始轮密钥异或）；  
- 主轮：`SubBytes`（字节替换）→`ShiftRows`（行移位）→`MixColumns`（列混合）→`AddRoundKey`（轮密钥加）；  
- 最后轮：移除`MixColumns`，仅`SubBytes`→`ShiftRows`→`AddRoundKey`。  


#### 2.3 密钥扩展：生成轮密钥
不同长度的密钥需要生成不同数量的“轮密钥”（每轮128位，与块长度相同）：  
- 128位密钥：需生成11个轮密钥（10轮加密 + 1个初始轮）；  
- 192位密钥：需生成13个轮密钥（12轮加密 + 1个初始轮）；  
- 256位密钥：需生成15个轮密钥（14轮加密 + 1个初始轮）。  

轮密钥通过“密钥扩展算法”从原始密钥生成，扩展规则随密钥长度略有差异（主要是循环左移位数和常量异或值），但核心目的是确保每轮密钥与原始密钥非线性关联，增强安全性。  


#### 2.4 密文块拼接
所有128位明文块加密完成后，对应的128位密文块按原始顺序拼接，形成最终密文。  


### 3. 不同密钥长度的核心差异总结
| 密钥长度 | 分块大小 | 加密轮数 | 轮密钥数量 | 安全性（大致） |
|----------|----------|----------|------------|----------------|
| 128位    | 128位    | 10轮     | 11个       | 高（主流应用） |
| 192位    | 128位    | 12轮     | 13个       | 更高           |
| 256位    | 128位    | 14轮     | 15个       | 最高（用于高安全场景） |  


### 4. 补充：分组密码模式（处理多块的逻辑）
AES分块加密本身仅处理单个128位块，实际应用中需通过“分组密码模式”（如CBC、GCM、ECB等）处理多个块，解决“相同明文块加密后密文相同”的问题。例如：  
- ECB模式：每个块独立加密（安全性差，不推荐）；  
- CBC模式：前一个密文块与当前明文块异或后再加密（需初始向量IV）；  
- GCM模式：同时提供加密和认证（用于HTTPS等场景）。  

这些模式不改变AES的分块大小和单块加密流程，仅定义多块之间的关联规则。


### 总结
AES的分块加密流程对128位、192位、256位密钥是**完全一致的**（均以128位为块，分块→填充→单块加密→拼接），差异仅在于加密轮数和轮密钥的生成数量。密钥越长，轮数越多，破解难度越大，但加密效率略有降低（轮数多导致计算量增加）。