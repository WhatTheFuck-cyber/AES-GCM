**<span style='color:blue'>文档中介绍了密钥扩展方法，并解析相关代码，附上密钥扩展的功能说明（[NIST AES 官方文档 - 英文](../.documentation/NIST-AES-EN.pdf)，相关中文翻译，可以参考[NIST AES 官方文档 - 中文翻译](../.documentation/NIST-AES-CN.docx)）</span>**

**<span style='color:blue'>在阅读本解析之前，请确保您知晓密钥派生的大体流程，并了解最终的密钥表是三维的，获取原始轮密钥应当从左往右竖着读取轮密钥矩阵</span>**

# 一、密钥扩展算法
AES（高级加密标准）的密钥扩展算法是将原始密钥（128位、192位或256位）扩展为一系列**轮密钥**的过程。这些轮密钥用于加密过程中每一轮的“AddRoundKey”操作，是AES安全性的核心环节之一。其核心目标是通过扩散和非线性变换，确保扩展出的轮密钥具有足够的随机性和独立性，避免原始密钥的结构泄露。


### 1 核心参数
密钥扩展的过程由三个关键参数决定，不同密钥长度对应不同参数：
- **Nk**：原始密钥中32位“字”（Word）的数量（1个字=4字节=32位）。  
  - 128位密钥：Nk=4（16字节=4×32位）；  
  - 192位密钥：Nk=6（24字节=6×32位）；  
  - 256位密钥：Nk=8（32字节=8×32位）。  
- **Nr**：加密轮数（轮密钥数量=Nr+1）。  
  - 128位密钥：Nr=10（11个轮密钥）；  
  - 192位密钥：Nr=12（13个轮密钥）；  
  - 256位密钥：Nr=14（15个轮密钥）。  
- **Nb**：AES数据块（128位）中32位字的数量，固定为4（128位=4×32位）。  


### 2 扩展目标
生成一个长度为 `Nb×(Nr+1)` 的**扩展密钥数组w**（数组元素为32位字），然后将w按轮拆分为 `Nr+1` 个轮密钥（每个轮密钥为4个字，对应4×4字节矩阵）。


### 3 扩展步骤
#### 3.1 初始化扩展密钥数组w
- 扩展密钥数组w的前Nk个字直接由原始密钥拆分得到：  
  原始密钥按字节顺序拆分为Nk个32位字，例如128位密钥（16字节）拆分为 `w[0]~w[3]`，每个字包含4个连续字节。

#### 3.2 生成后续扩展字（i ≥ Nk）
对于i从Nk到 `Nb×(Nr+1)-1`，按以下规则生成w[i]：  
- 定义临时变量 `temp = w[i-1]`（基于前一个字）；  
- 根据i的位置执行不同变换，再与 `w[i-Nk]` 异或得到w[i]。  

具体分三种情况：

##### （1）当 `i % Nk == 0`（每Nk个字触发一次“轮变换”）
对temp执行三步变换：  
- **RotWord（循环左移）**：将temp的4个字节循环左移1位（如 `[b0, b1, b2, b3] → [b1, b2, b3, b0]`），增强扩散性。  
- **SubWord（S盒替换）**：对RotWord后的每个字节应用AES的S盒（正向替换），引入非线性，破坏密钥的线性结构。  
- **Rcon（轮常量异或）**：将SubWord的结果与轮常量 `Rcon[i/Nk]` 异或。轮常量是预先定义的数组，第j个值为 `[RC[j], 0x00, 0x00, 0x00]`，其中 `RC[1]=0x01`，`RC[j]=RC[j-1]×2 mod 0x11b`（GF(2?)域上的乘法）。轮常量确保每一轮的扩展密钥有差异，避免对称性。  

最终：`w[i] = w[i-Nk]  temp`（为异或）。


##### （2）当 `Nk > 6 且 i % Nk == 4`（仅256位密钥适用，Nk=8）
256位密钥需要额外增强安全性，此时对temp仅执行**SubWord**变换（无RotWord和Rcon），再与 `w[i-Nk]` 异或：  
`w[i] = w[i-Nk]  SubWord(temp)`。


##### （3）其他情况（i % Nk ≠ 0 且不满足上述256位特殊条件）
直接用前一个字与 `w[i-Nk]` 异或：  
`w[i] = w[i-Nk]  w[i-1]`。


#### 3.3 生成轮密钥矩阵
扩展密钥数组w生成后，按轮拆分：  
- 第0轮密钥由 `w[0]~w[3]` 组成；  
- 第1轮密钥由 `w[4]~w[7]` 组成；  
- ...  
- 第Nr轮密钥由 `w[Nr×4]~w[(Nr+1)×4 -1]` 组成。  

每个轮密钥转换为4×4字节矩阵（按列填充），例如：`w[0] = [b0, b1, b2, b3]` 对应矩阵第0列 `[b0, b1, b2, b3]`（行索引0~3）。


# 二、密钥扩展说明

你提供的`key_expansion`函数是AES加密算法中的**密钥扩展模块**，其核心作用是将原始输入密钥（128位、192位或256位）扩展为一系列**轮密钥（Round Keys）**，用于AES加密过程中每一轮的“轮密钥加（AddRoundKey）”操作。


### 1 为什么需要密钥扩展？ 
AES加密不是只使用原始密钥一次，而是分为多轮操作（128位密钥10轮，192位12轮，256位14轮），每一轮都需要一个独立的“轮密钥”与当前状态矩阵进行异或。原始密钥长度不足以覆盖所有轮次，因此需要通过**密钥扩展算法**从原始密钥生成所有轮密钥。


### 2 函数核心变量解析
在理解代码前，先明确AES中的几个关键参数（代码中已体现）：
- `Nk`：原始密钥的“32位字（Word）”数量。128位密钥（16字节）对应`Nk=4`（16/4=4），192位对应`Nk=6`，256位对应`Nk=8`。
- `Nr`：加密总轮数。128位密钥`Nr=10`，192位`Nr=12`，256位`Nr=14`（代码中通过`Nk`判断）。
- `Nb`：AES状态矩阵的列数，固定为4（AES的状态矩阵是4x4字节矩阵，共16字节）。
- `w`：扩展密钥的“字数组”，每个“字”是32位（4字节）。长度为`Nb*(Nr+1)`（因为每轮需要`Nb`个字，共`Nr+1`轮，包括初始轮）。
- `Rcon`：轮常量（Round Constant）数组，用于打破扩展过程的对称性，确保生成的轮密钥足够随机。


### 3 函数执行流程详解
整个密钥扩展分为3个核心步骤：**初始化原始密钥字**、**扩展生成新密钥字**、**转换为轮密钥矩阵**。


#### 3.1 初始化原始密钥字（填充`w`的前`Nk`个字）
```python
for i in range(Nk):
    w[i] = list(key_bytes[4*i : 4*(i+1)])
```
- 原始密钥（`key_bytes`）是字节数组（16/24/32字节，对应128/192/256位）。
- 代码将原始密钥按4字节一组拆分为`Nk`个“字”（32位），存入`w`数组的前`Nk`个位置。例如：128位密钥（16字节）会拆分为4个字（`w[0]`到`w[3]`）。


#### 3.2 扩展生成剩余密钥字（从`i=Nk`到`i=Nb*(Nr+1)-1`）
这是密钥扩展的核心，通过对已有密钥字的变换生成新的密钥字，关键逻辑是：
```python
for i in range(Nk, Nb * (Nr + 1)):
    temp = list(w[i-1])  # 临时变量，基于前一个字生成
    # 核心变换：当i是Nk的倍数时（如i=4,8,12...）
    if i % Nk == 0:
        # 步骤1：循环左移1位（RotWord操作）
        temp = temp[1:] + temp[:1]  # 例如[0x01,0x02,0x03,0x04]→[0x02,0x03,0x04,0x01]
        # 步骤2：S盒替换（SubWord操作）
        temp = [SBOX(b) for b in temp]  # 每个字节通过S盒替换，引入非线性
        # 步骤3：与轮常量异或（Rcon）
        temp[0] = temp[0] ^ Rcon[i // Nk]  # 仅第一个字节与轮常量异或，打破对称性
    # 特殊处理：256位密钥（Nk=8）时，i%Nk==4需额外S盒替换
    elif Nk > 6 and i % Nk == 4:
        temp = [SBOX(b) for b in temp]
    # 生成新字：与Nk个位置前的字异或
    w[i] = [w[i-Nk][j] ^ temp[j] for j in range(4)]
```

**关键变换的作用**：
- **RotWord（循环左移）**：对字节进行移位，增强扩散性（让原始密钥的比特分布到更多轮密钥中）。
- **SubWord（S盒替换）**：通过S盒的非线性变换，确保轮密钥之间的关联性足够复杂，抵抗密码分析。
- **轮常量（Rcon）**：每一轮的常量不同（`Rcon[1]=0x01`、`Rcon[2]=0x02`、`Rcon[3]=0x04`...），用于避免扩展过程中出现对称或重复的轮密钥。
- **异或操作**：新密钥字由前序密钥字异或生成，确保轮密钥与原始密钥紧密关联且足够分散。


#### 3.3 转换为轮密钥矩阵（供加密轮使用）
```python
round_keys_matrices = []
for round_num in range(Nr + 1):
    round_key_matrix = [[0]*4 for _ in range(4)]
    for c in range(4):
        word_from_w = w[round_num * Nb + c]
        for r in range(4):
            round_key_matrix[r][c] = word_from_w[r]
    round_keys_matrices.append(round_key_matrix)
```
- 扩展后的`w`数组是“字”的线性排列，而AES加密中需要的轮密钥是**4x4字节矩阵**（与状态矩阵维度一致）。
- 代码将`w`数组按轮拆分（每轮`Nb=4`个字），并将每个字的4字节按“列优先”方式填入4x4矩阵（`round_key_matrix[r][c]`表示第r行第c列）。
- 最终生成`Nr+1`个轮密钥矩阵（包括初始轮和`Nr`轮加密），用于每一轮的“轮密钥加”操作（状态矩阵与轮密钥矩阵逐字节异或）。


### 4 总结
这个`key_expansion`函数的核心作用是：  
**从原始密钥出发，通过一系列非线性变换（S盒）、移位（RotWord）和异或操作，生成AES加密所需的所有轮密钥，确保每一轮加密都有独立且安全的密钥用于混淆和扩散，最终保障AES算法的安全性**。

轮密钥的质量直接影响AES的抗攻击能力，而这个扩展过程通过引入非线性、扩散和轮常量，确保生成的轮密钥足够随机且与原始密钥关联紧密，是AES加密流程中不可或缺的环节。

# 三、密钥扩展函数优化：
- 优化内存使用，一轮加密 / 解密可以节省 KB 级内存。