**<span style='color:blue'>文档中介绍了 S 盒与 S^-1^ 盒的计算方法，并解析相关代码，附上 S 盒的功能说明（[NIST AES 官方文档 - 英文](../.documentation/NIST-AES-EN.pdf)，相关中文翻译，可以参考[NIST AES 官方文档 - 中文翻译](../.documentation/NIST-AES-CN.docx)）</span>**

**<span style='color:blue'>在阅读本解析之前，请确保您知晓\(GF(2^8)\)有限域的相关基础知识，并会在\(GF(2^8)\)上进行简单的计算</span>**

# 一、S盒相关计算说明

### （一）S 盒计算
S 盒的输出通过两步计算得到：
1. **求有限域\(GF(2^8)\)上的乘法逆元**  
   对于输入字节 \( b \)：
   - 若 \( b = 0x00 \)，逆元定义为 \( 0x00 \)；
   - 若 \( b \neq 0x00 \)，求逆元 \( \tilde{b} \) 使得 \( b \cdot \tilde{b} \equiv 1 \pmod{0x11b} \)
   其中 \( 0x11b \) 对应不可约多项式 \(p(x) = x^8 + x^4 + x^3 + x + 1 \)。

2. **仿射变换**  
   对逆元 \( \tilde{b} \) 的 8 位（\( \tilde{b}_0 \) 为最低位，\( \tilde{b}_7 \) 为最高位）进行如下变换，得到输出字节 \( b' \)：\[
   b'_i = \tilde{b}_i \oplus \tilde{b}_{(i+4) mod\ 8} \oplus \tilde{b}_{(i+5) mod\ 8} \oplus \tilde{b}_{(i+6) mod\ 8} \oplus \tilde{b}_{(i+7) mod\ 8} \oplus c_i
   \]<span style='color:green'>其中 \( c_i \) 是常数字节 \( 0x63 \)（二进制 `01100011`）的第 \( i \) 位。</span>
   **<span style='color:red'>请注意，\(\tilde{b}_{(i+j) mod\ 8}\)表示循环右移动\(j\)位！</span>**

### （二）S^-1^ 盒计算
S^-1^ 盒是 S 盒的逆操作，计算步骤相反：
1. **逆仿射变换**  
   对于输入字节 \( b' \)，先进行逆仿射变换得到 \( \tilde{b} \)，具体公式为S盒仿射变换的逆运算：\[
   \tilde{b}_i = b'_i \oplus b'_{(i+2) mod\ 8} \oplus b'_{(i+5) mod\ 8} \oplus b'_{(i+7) mod\ 8} \oplus d_i
   \]<span style='color:green'>其中 \( d_i \) 是常数字节 \( 0x05 \)（二进制 `00000101`）的第 \( i \) 位。</span>

2. **求有限域\(GF(2^8)\)上的乘法逆元**  
   对逆仿射变换的结果 \( \tilde{b} \) 求逆元：
   - 若 \( \tilde{b} = 0x00 \)，逆元为 \( 0x00 \)；
   - 若 \( \tilde{b} \neq 0x00 \)，求逆元 \( b \) 使得 \( \tilde{b} \cdot b \equiv 1 \pmod{0x11b} \)，即得到原始输入 \( b \)。
   其中 \( 0x11b \) 对应不可约多项式 \(p(x) = x^8 + x^4 + x^3 + x + 1 \)。

### （三）有限域\(GF(2^8)\)上的乘法计算
在有限域 \(GF(2^8)\) 上，乘法运算遵循多项式乘法规则，并使用模多项式 \(m(x)=x^{8}+x^{4}+x^{3}+x + 1\) 进行取模运算。例如，计算 \(0x57\) 与 \(0x83\) 的乘积：
1. 将 \(0x57\) 和 \(0x83\) 转换为多项式形式：
   - \(0x57\) 对应 \(x^7 + x^5 + x^3 + x\)；
   - \(0x83\) 对应 \(x^7 + x^6 + x^2 + x\)。
2. 进行多项式乘法，并取模 \(m(x)\)：
   - 乘积为 \(x^{14} + x^{13} + x^{12} + x^{11} + x^{10} + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x\)；   - 取模 \(m(x)\) 后，得到 \(x^7 + x^5 + x^3 + x\)，即 \(0x57\) 与 \(0x83\) 的乘积为 \(0x2b\)。

### （四）有限域\(GF(2^8)\)上的乘法逆元计算

官方文档对有限域\(GF(2^8)\)上乘法逆元的计算方法有详细介绍，主要有两种方式：
1. **基于公式计算**：对于字节 \(b \neq 0x00\)，其在GF(2?)上的乘法逆元 \(b^{-1}\) 可通过公式 \(b^{-1}=b^{254}\) 计算。这是利用了有限域的性质，在GF(2?)中，非零元素的乘法逆元可以通过该元素的特定幂次运算得到 。
2. **扩展欧几里得算法**：设 \(b(x)\) 是代表字节 \(b\) 的多项式，通过对 \(b(x)\) 和不可约多项式 \(m(x)=x^{8}+x^{4}+x^{3}+x + 1\) 应用扩展欧几里得算法，可以找到多项式 \(a(x)\) 和 \(c(x)\)，使得 \(b(x)a(x)+m(x)c(x)=1\)。此时，\(a(x)\) 就是代表 \(b^{-1}\) 的多项式，即 \(b\) 的乘法逆元。



**扩展欧几里得算法是计算乘法逆元的核心方法，其核心思想是通过多项式运算找到满足“贝祖等式”的系数，最终推导出逆元。以下详细介绍具体步骤：**

##### [1] 基础准备：多项式表示与运算规则
在GF(2?)中，每个字节对应一个8次以下的多项式（系数为0或1），例如：
- 字节 `0x05`（二进制 `00000101`）对应多项式 \( b(x) = x^2 + 1 \)；
- 不可约多项式 \( m(x) = x^8 + x^4 + x^3 + x + 1 \)（即 `0x11b`），是运算的模多项式。

**运算规则**：
- 多项式加法：系数对应异或（模2加法），例如 \( (x^2 + 1) + (x + 1) = x^2 + x \)（系数1+1=0，1+0=1）；
- 多项式乘法：常规多项式相乘后，系数模2，再对 \( m(x) \) 取余（确保次数<8）。


##### [2]扩展欧几里得算法的目标
对于给定字节对应的多项式 \( b(x) \)（非零），需找到多项式 \( a(x) \) 和 \( c(x) \)，使得：  
\[ b(x) \cdot a(x) + m(x) \cdot c(x) = 1 \]  
此时 \( a(x) \) 即为 \( b(x) \) 的乘法逆元（因 \( m(x) \cdot c(x) \) 项模 \( m(x) \) 为0，故 \( b(x) \cdot a(x) \equiv 1 \pmod{m(x)} \)）。


##### [3]算法步骤（多项式版）
扩展欧几里得算法通过**逐步替换余数**求解，具体步骤如下：

###### 步骤1：初始化参数
设两个多项式 \( r_0 = m(x) \)、\( r_1 = b(x) \)（待求逆元的多项式），并初始化系数：  
- \( s_0 = 1 \)，\( t_0 = 0 \)（对应 \( r_0 = s_0 \cdot m(x) + t_0 \cdot b(x) \)）；  
- \( s_1 = 0 \)，\( t_1 = 1 \)（对应 \( r_1 = s_1 \cdot m(x) + t_1 \cdot b(x) \)）。  


###### 步骤2：迭代计算余数与系数
循环执行以下操作，直到 \( r_n = 0 \)：  
1. 用 \( r_{i-1} \) 除以 \( r_i \)，得到商 \( q_i \) 和余数 \( r_{i+1} \)（满足 \( r_{i-1} = q_i \cdot r_i + r_{i+1} \)，且 \( \deg(r_{i+1}) < \deg(r_i) \)）；  
2. 更新系数：  
   \[ s_{i+1} = s_{i-1} + q_i \cdot s_i \]  \[ t_{i+1} = t_{i-1} + q_i \cdot t_i \]（所有运算为GF(2)上的多项式运算，加法即异或）。  


###### 步骤3：获取逆元
当 \( r_{n-1} = 1 \) 时（因 \( m(x) \) 不可约，非零多项式与 \( m(x) \) 的最大公因子必为1），此时 \( t_{n-1} \) 即为 \( b(x) \) 的逆元多项式 \( a(x) \)，对应的字节即为所求逆元。


##### [4]实例：计算0x05的逆元（验证0x52）
以字节 `0x05`（多项式 \( b(x) = x^2 + 1 \)）为例，演示如何通过算法得到逆元 `0x52`：

###### 步骤1：初始化
- \( r_0 = m(x) = x^8 + x^4 + x^3 + x + 1 \)，\( s_0 = 1 \)，\( t_0 = 0 \)；  
- \( r_1 = b(x) = x^2 + 1 \)，\( s_1 = 0 \)，\( t_1 = 1 \)。  


###### 步骤2：迭代计算（关键步骤）
1. **第一次除法**：\( r_0 \div r_1 \)  
   - 商 \( q_1 = x^6 + x^2 \)（因 \( (x^2 + 1)(x^6 + x^2) = x^8 + x^4 + x^2 \)，与 \( r_0 \) 最接近）；  
   - 余数 \( r_2 = r_0 + q_1 \cdot r_1 = (x^8 + x^4 + x^3 + x + 1) + (x^8 + x^4 + x^2) = x^3 + x + 1 + x^2 \)（即 \( x^3 + x^2 + x + 1 \)）；  
   - 系数：\( s_2 = s_0 + q_1 \cdot s_1 = 1 + 0 = 1 \)；\( t_2 = t_0 + q_1 \cdot t_1 = 0 + (x^6 + x^2) \cdot 1 = x^6 + x^2 \)。  

2. **第二次除法**：\( r_1 \div r_2 \)  
   - 商 \( q_2 = x + 1 \)（因 \( (x^3 + x^2 + x + 1)(x + 1) = x^4 + 1 \)，次数高于 \( r_1 \)，实际取低次项调整后商为 \( 0 \)，过程略）；  
   - 持续迭代，最终当 \( r_k = 1 \) 时，得到 \( t_k = x^6 + x^4 + x \)，对应字节 `0x52`（二进制 `01010010`）。  

# 二、S 盒代码解析

### （I）这里仅介绍 S 盒正向变换：

```python
def SBOX(data: bytearray) -> None:
    '''S盒正向变换，支持操作一个字节数组的变换'''
    for i in range(len(data)):
        val = data[i]  # 取出字节（整数类型，可直接位运算）
        
        if val == 0:
            data[i] = 0x63  # 直接修改原位置
            continue
        
        # 1. 有限域逆元计算（扩展欧几里得算法）
        u, v = val, 0x11B
        t, s = 1, 0
        while u != 1:
            j = len(bin(u)) - len(bin(v))
            if j < 0:
                u, v = v, u
                t, s = s, t
                continue
            u ^= (v << j)
            t ^= (s << j)
            u &= 0xFF  # 确保在单字节范围内
        
        # 2. 仿射变换（位运算）
        b = t & 0xFF
        c = b
        for _ in range(4):
            b = ((b << 1) | (b >> 7)) & 0xFF  # 循环左移
            c ^= b
        
        # 3. 结果写回原bytearray（原地修改）
        data[i] = (c ^ 0x63) & 0xFF
```

#### 1 核心符号映射表（代码 ? 算法）
先明确代码变量与算法中符号的对应关系：

| 算法中的符号       | 含义                                      | 代码中的变量 | 代码中的含义（对应算法）                  |
|--------------------|-------------------------------------------|--------------|-------------------------------------------|
| \(m(x)\)             | 不可约多项式（\(x^8 + x^4 + x^3 + x + 1\)，即0x11b） | `v`（初始值） | 初始时`v = 0x11b`，对应\(m(x)\)            |
| \(b(x)\)             | 待求逆元的多项式（输入字节`val`）          | `u`（初始值） | 初始时`u = val`，对应\(b(x)\)               |
| \(r_0, r_1, r_i\)       | 迭代中的余数多项式（\(r_0 = m(x)\), \(r_1 = b(x)\)） | `u、v`       | 循环中动态表示\(r_i\)和\(r_{i-1}\)（会交换）      |
| \(s_0, s_1, s_i\)       | 系数多项式（对应\(m(x)\)的系数）             | `s`          | 代码中`s`对应算法的\(s_i\)                   |
| \(t_0, t_1, t_i\)       | 系数多项式（对应\(b(x)\)的系数）             | `t`          | 代码中`t`对应算法的\(t_i\)                   |
| \(q_i\)               | 多项式除法的商（\(x^j\)，`j`是次数差）        | `j`衍生的移位 | 代码中`v << j`对应\(q_i・r_i\)（\(q_i = x^j）\)      |


#### 2 步骤对应：代码如何实现算法
算法的3个核心步骤，在代码中是逐行对应的，只是用位运算简化了多项式操作：


##### 算法步骤1：初始化参数（代码初始化部分）
算法初始化：  
- \(r_0 = m(x)\)，\(r_1 = b(x)\)
- \(s_0 = 1\)，\(t_0 = 0\)（对应\(r_0 = s_0・m(x) + t_0・b(x)\)）  
- \(s_1 = 0\)，\(t_1 = 1\)（对应\(r_1 = s_1・m(x) + t_1・b(x)\)）  

代码对应：  
```python
u, v = val, 0x11B  # u = r_1 = b(x)，v = r_0 = m(x)
t, s = 1, 0        # t = t_1 = 1（r_1的b(x)系数），s = s_1 = 0（r_1的m(x)系数）
```
? 解释：代码中`u`和`v`初始值对应\(r_1\)和\(r_0\)，`t`和`s`对应\(t_1\)和\(s_1\)，完全符合算法的初始等式。


##### 算法步骤2：迭代计算（代码循环部分）
算法迭代逻辑：  
循环计算\(r_{i+1} = r_{i-1} + q_i・r_i\)（\(GF(2^8)\)中“+”是异或），并更新系数：  
\(s_{i+1} = s_{i-1} + q_i・s_i\)
\(t_{i+1} = t_{i-1} + q_i・t_i\) 

代码对应（`while u != 1`循环）：  
```python
j = len(bin(u)) - len(bin(v))  # 计算次数差j，q_i = x^j（商是x的j次方）
if j < 0:
    # 若r_{i-1}次数 < r_i，交换r_{i-1}和r_i，同步交换系数
    u, v = v, u          # 交换r_{i-1}和r_i（u和v角色互换）
    t, s = s, t          # 交换系数s和t（对应s_{i-1}与s_i、t_{i-1}与t_i互换）
    continue
# 计算新余数r_{i+1} = r_{i-1} XOR q_i・r_i（异或即GF(2)中的加法）
u ^= (v << j)  # v << j 等价于 q_i・r_i（x^j乘以r_i），u更新为r_{i+1}
# 更新系数t_{i+1} = t_{i-1} XOR q_i・t_i（s对应t_i，左移j等价于q_i・t_i）
t ^= (s << j)
u &= 0xFF  # 确保余数是8位多项式（符合GF(2^8)范围）
```
? 解释：  
- \(j\)是\(r_{i-1}\)与\(r_i\)的次数差，\(q_i = x^j\)（多项式商）；  
- \(v << j\)是\(r_i\)乘以\(q_i\)（左移\(j\)位等价于多项式乘以\(x^j\)）；  
- `u ^= (v << j)`对应\(r_{i+1} = r_{i-1} + q_i・r_i\)（异或是\(GF(2)\)的加法）；  
- `t ^= (s << j)`对应系数更新\(t_{i+1} = t_{i-1} + q_i・t_i\)，完全匹配算法。  
- 这一步的本质是将\(r_{i-1}\)和\(r_i\)以及\(s_{i-1}\)和\(s_i\)的角色对调，以保证等式\(u = s・m(x) + t・b(x)\)始终成立。相当于\(s\)参数的更新放在if语句中，其实\(s\)也是更新过的。


##### 算法步骤3：获取逆元（循环结束）
算法结论：  
当\(r_{n-1} = 1\)时，\(t_{n-1}\)是\(b(x)\)的逆元（因\(b(x)・t_{n-1} ≡ 1 \mod m(x)\)）。

代码对应：  
```python
# 当循环结束时，u = 1（即r_{n-1} = 1）
b = t & 0xFF  # t对应算法的t_{n-1}，即逆元
```
? 解释：循环终止时\(u=1\)（对应\(r_{n-1}=1\)），此时\(t\)就是算法中的\(t_{n-1}\)，即\(val\)的逆元。

##### 3 仿射变换（代码仿射变换部分）
- 注意区分循环左移和循环右移即可

### （II）AES.std_SBOX：
- 固定的 S 盒，可以直接查表，无需计算

### （III）\(GF(2^8)\)上的逆元计算：
```python
def inverse(val : int, mod : int) -> int:
   '''有限域逆元计算（扩展欧几里得算法）'''
   if val == 0:  # 0 的逆元定义为 0
      return 0
    
   # 初始化，这里的 0 指代循环中的 i-1；1 指代循环中的 i
   r0, r1 = mod, val
   s0, s1 = 1, 0
   t0, t1 = 0, 1
    
   while r1 != 0:
      # 多项式除法：求商q和余数r，使得r_{i-1} = q*r_{i} + r_{i+1}（模2运算）
      q = 0
      degree_r0, degree_r1 = r0.bit_length() - 1, r1.bit_length() - 1
        
      while degree_r0 >= degree_r1:
         # GF(2^8) 上多项式除法的余数求法：高位对齐后作异或
         # GF(2^8) 上多项式除法的除数求法：高位对齐的左移数
         shift = degree_r0 - degree_r1
         q ^= (1 << shift)  # 用于 s 和 t 的更新
         r0 ^= (r1 << shift)
            
         if r0 == 0:  # 直接处理 GF(2^8) 上多项式除法计算完的余数是 0 的情况
            degree_r0 = -1
            break
         degree_r0 = r0.bit_length() - 1
        
      # 迭代更新：t 和 s 是滑动窗口式更新；r 是倒序更新。【这取决于 GF(2^8) 上多项式除法的算法】
      r0, r1 = r1, r0
      s0, s1 = s1, s0 ^ _poly_mul_on_GF(q, s1)
      t0, t1 = t1, t0 ^ _poly_mul_on_GF(q, t1)

   # 算法中提到，当 r_{n-1} = 1 时（等价于 r_{n} = 0），t_{n-1} 是 b(x) 的逆元
   return t0 & 0xFF
```

### （IV）\(GF(2^8)\)上的乘法计算：
```python
def _poly_mul_on_GF(a: int, b: int, mod : int = MOD) -> int:
   '''有限域上的多项式乘法并处理模约减'''
   result = 0
   a &= 0xFF
   b &= 0xFF

   # 有限域上的多项式乘法
   for i in range(8):
      if (a & (1 << i)) != 0:  # a 的第 i 位为 1，则进行一次移位异或计算
         result ^= b << i

   # 模约简：将结果约简到8位以内（使用 GF(2^8) 上的模约减）
   for i in range(15, 7, -1):  # 从最高位开始处理（最多 15 位）
      if (result & (1 << i)) != 0:  # result 的第 i 位为 1，则进行一次模约简计算
         result ^= (mod << (i - 8))
    
   return result & 0xFF
```


# 三、S 盒功能描述：

在AES（Advanced Encryption Standard）加密算法中，**S盒（Substitution Box）** 是核心组件之一，承担着字节级的非线性替换功能，是AES实现“混淆”（Confusion）特性的关键，也是整个算法中唯一的非线性操作步骤。其设计直接影响AES的安全性，经过严格的密码学特性验证，能够有效抵抗线性攻击、差分攻击等常见密码分析方法。


### **1 S盒的本质：非线性替换表**
S盒是一个8×8的查找表（Lookup Table），输入一个8位字节（0x00到0xFF，共256个可能值），输出唯一对应的8位字节，形成**双射关系**（一一对应，确保可逆，满足解密需求）。例如：
- 输入0x00，S盒输出0x63；
- 输入0x01，S盒输出0x7C；
- ...（完整S盒表可参考AES标准文档）。

这种替换不是随机的，而是通过严格的数学构造生成，确保每个输入字节都被映射到唯一输出字节，且逆S盒（用于解密）同样存在。



### **2 S盒在AES中的核心功能与作用**
AES的加密流程包括**字节替换（SubBytes）、行移位（ShiftRows）、列混合（MixColumns）、轮密钥加（AddRoundKey）** 四轮操作，其中**字节替换完全依赖S盒实现**，其功能可概括为以下三点：


#### 2.1 提供“混淆”特性，隐藏明文与密钥的关系  
密码学中的“混淆”（Confusion）指通过复杂的非线性变换，使密文与明文、密钥之间的关系变得模糊，让攻击者难以通过密文推导出明文或密钥的结构。  
- 线性变换（如移位、异或）无法提供混淆，因为线性关系可被轻易建模（例如，线性变换的组合仍是线性的）。  
- S盒的非线性是AES混淆特性的唯一来源：其输出与输入的关系无法用线性方程表示，即使攻击者观察到大量明文-密文对，也难以建立输入（明文/密钥）与输出（密文）之间的线性近似关系，从而有效抵抗**线性密码分析**（一种通过寻找线性近似破解密码的方法）。


#### 2.2 支持“扩散”特性，实现雪崩效应  
“扩散”（Diffusion）指将明文或密钥中单个比特的变化扩散到整个密文，使得微小的输入变化（如明文或密钥的1比特翻转）导致密文产生巨大变化（即“雪崩效应”）。  
- S盒本身是字节内的替换（单个字节的变化仅影响自身输出），但结合AES后续的“行移位”和“列混合”操作，可将S盒的输出变化扩散到整个状态矩阵（16字节）。  
- 例如：明文的1个比特变化会导致S盒输出的多个比特变化，经行移位和列混合后，最终密文的多数比特都会改变。这种扩散能力使攻击者无法通过局部变化推测整体结构，有效抵抗**差分密码分析**（利用输入差分与输出差分的统计关系破解密码）。


#### 2.3 抵抗特定密码攻击，保障算法安全性  
S盒的设计经过严格优化，具备多项关键密码学特性，直接决定了AES的抗攻击能力：  
- **高非线性度**：S盒的输出与输入的线性相关性极低（用“非线性度”衡量），使线性密码分析难以找到有效的线性近似式。  
- **低差分均匀性**：对于任意非零输入差分（即两个输入的异或值），对应的输出差分（两个输出的异或值）出现的概率极低，使差分密码分析难以利用差分分布规律。  
- **无固定点和反固定点**：不存在输入`x`满足`S(x) = x`（固定点）或`S(S(x)) = x`（反固定点），避免攻击者利用特殊值构造攻击。  
- **严格雪崩准则**：输入的1个比特变化会导致输出的约4个比特变化（接近理想值），强化雪崩效应。  


#### 2.4 确保解密的可逆性  
由于S盒是双射（一一对应），其逆变换（逆S盒）同样存在，且构造过程是S盒的逆操作：先对输入进行“逆仿射变换”，再求GF(2?)上的乘法逆元。这保证了AES解密过程能准确还原明文，是算法可逆性的基础。


### **3 总结**
S盒是AES的“心脏”，其核心作用是通过**非线性替换**提供混淆特性，结合其他线性操作（行移位、列混合等）实现扩散，最终使AES具备极强的抗攻击能力。没有S盒的非线性，AES的安全性将完全崩塌――线性操作的组合无法抵抗现代密码分析方法。因此，S盒的设计是AES成为全球标准加密算法的关键因素之一。